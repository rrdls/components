import * as THREE from "three";
import { Component, Disposable, Event } from "../../base-types";
import { Components } from "../Components";
export declare class ScreenCuller extends Component<null> implements Disposable {
    private components;
    readonly updateInterval: number;
    readonly rtWidth: number;
    readonly rtHeight: number;
    readonly autoUpdate: boolean;
    readonly renderer: THREE.WebGLRenderer;
    readonly renderTarget: THREE.WebGLRenderTarget;
    readonly bufferSize: number;
    readonly materialCache: Map<string, THREE.MeshBasicMaterial>;
    readonly worker: Worker;
    name: string;
    enabled: boolean;
    viewUpdated: Event<unknown>;
    needsUpdate: boolean;
    meshColorMap: Map<string, THREE.Mesh<THREE.BufferGeometry<THREE.NormalBufferAttributes>, THREE.Material | THREE.Material[]>>;
    renderDebugFrame: boolean;
    visibleMeshes: THREE.Mesh[];
    colorMeshes: Map<string, THREE.InstancedMesh<THREE.BufferGeometry<THREE.NormalBufferAttributes>, THREE.Material | THREE.Material[]>>;
    meshes: Map<string, THREE.Mesh<THREE.BufferGeometry<THREE.NormalBufferAttributes>, THREE.Material | THREE.Material[]>>;
    currentVisibleMeshes: Set<string>;
    recentlyHiddenMeshes: Set<string>;
    private readonly _transparentMat;
    private _disposer;
    private _colors;
    private readonly _scene;
    private readonly _buffer;
    constructor(components: Components, updateInterval?: number, rtWidth?: number, rtHeight?: number, autoUpdate?: boolean);
    get(): null;
    dispose(): void;
    add(mesh: THREE.Mesh | THREE.InstancedMesh): void;
    updateVisibility: (force?: boolean) => Promise<void>;
    private handleWorkerMessage;
    private getMaterial;
    private isTransparent;
    private getNextColor;
}
